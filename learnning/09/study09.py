# TODO 摄像头模型和增强现实


# 6个变量来表示6DOF姿态：
# （1）tx：物体沿x轴的平移。
# （2）ty：物体沿y轴的平移。
# （3）tz：物体沿z轴的平移。
# （4）rx：物体的罗德里格斯旋转矢量的第1个元素。
# （5）ry：物体的罗德里格斯旋转矢量的第2个元素。
# （6）rz：物体的罗德里格斯旋转矢量的第3个元素。

"""
3D图像跟踪和视觉增强现实所涉及的典型步骤:
（1）定义摄像头和镜头参数。我们会在本章介绍这个主题。
（2）初始化一个卡尔曼滤波器以稳定6DOF跟踪结果。有关卡尔曼滤波器的更多信息，请参阅第8章。
（3）选择一幅参考图像，代表想要跟踪的物体表面。对于示例demo，物体将是一个平面，例如打印图像的一张纸。
（4）创建3D点列表，代表物体的顶点。坐标单位可以是任意单位，例如米、毫米或者其他任意单位。例如，你可以任意定义一个单位，使其等于物体的高度。
（5）从参考图像中提取特征描述符。对于3D跟踪应用程序，ORB是一种流行的描述符选择，因为ORB即使在智能手机这样的普通硬件上也可以实时计算。示例demo将使用ORB。有关ORB的更多信息，请参阅第6章。
（6）利用步骤（4）中使用的相同映射，把特征描述符从像素坐标转换为3D坐标。
（7）开始从摄像头捕捉帧。对于每一帧，执行以下步骤：
    1）提取特征描述符，尝试找到参考图像和帧之间的良好匹配。示例demo将使用基于FLANN的匹配和比率检验。有关匹配描述符方法的更多信息，请参见第6章。
    2）如果找到的好的匹配数不够，则继续下一帧。否则，继续下面的步骤。
    3）基于摄像头和镜头参数、匹配信息和参考物体的3D模型，尝试寻找跟踪物体的6DOF姿态的一个好的估计。为此，我们会使用cv2.solvePnPRansac函数。
    4）应用卡尔曼滤波器稳定6DOF姿态，这样帧间就不会有太多抖动。
    5）根据摄像头和镜头参数以及6DOF跟踪结果，在被跟踪的画面中的物体顶部绘制一些3D图形的投影。
"""

# TODO　cv2.solvePnPRansac用于估计相机位姿

# 4个返回值：
# ·retval：如果求解器收敛于一个解，就为True，否则为False。
# ·rvec：该数组包含rx、ry和rz（6DOF姿态中的3个旋转自由度）。
# ·tvec：该数组包含tx、ty和tz（6DOF姿态中的3个平移（位置）自由度）。
# ·inliers：如果求解器收敛于一个解，则该向量包含与解一致的输入点（在objectPoints和imagePoints中）的索引

#  12个参数：
#  ·objectPoints：这是一个3D点数组，表示没有平移和旋转时（或者，当6DOF姿态变量都为0时）对象的关键点。
#  ·imagePoints：这是一个2D点数组，表示图像中匹配的对象关键点。具体来说，把imagePoints[i]看作objectPoints[i]的匹配。
#  ·cameraMatrix：这个2D数组就是摄像头矩阵，可以用9.2.1节中描述的方式推导出来。
#  ·distCoeffs：这是畸变系数数组。如果它们未知，那么可以（简单地）假设它们都是0，如9.2.1节所述。
#  ·rvec：如果求解器收敛于一个解，它会把解的rx、ry和rz值都放入这个数组。
#  ·tvec：如果求解器收敛于一个解，它会把解的tx、ty和tz值都放入这个数组。
#  ·useExtrinsicGuess：如果为True，求解器将rvec和tvec中的参数值作为初始猜测，再尝试找到接近这些值的一个解。否则，求解器在其求解过程中采用无偏方法。
#  ·iterationsCount：这是求解器应该尝试的最大迭代次数。如果在这个迭代数后，它仍不收敛到某个解，它就放弃。
#  ·reprojectionError：这是求解器可以接受的最大重投影误差。如果点的重投影误差比它大，求解器就把该点当作异常值来处理。
#  ·confidence：求解器尝试收敛到置信度大于或等于该值的解。
#  ·inliers：如果求解器收敛于一个解，它将把解的内点索引放入这个数组。
#  ·flags：该标志指定求解器的算法。
#       默认情况下为cv2.SOLVEPNP_ITERATIVE，它是最小化重投影误差的一种方法，并且没有特殊的限制，所以通常是最好的选择。
#       一个有用的替代方案是cv2.SOLVEPNP_IPPE（基于无穷小平面的姿态估计），但它仅限于平面物体。
